#include<iostream>
using namespace std;
typedef int ElemType;
typedef struct LNode {
	ElemType data;
	struct LNode* next;
}LNode,*LinkList;     
//->有解引用，即(*LinkList).___
//单链表的初始化
bool InitList(LinkList& L)
{
	L = new LNode;
	L->next = NULL;
	return true;
}
//单链表的取值
bool GetElem(LinkList L, int i, ElemType& e)
{
	LNode* p = L->next;//指向首元结点
	int j = 1;
	while (p && j < i)
		//首先保证p指向的节点不为空即为存在，再确保j指向i
	{
		p = p->next;
		++j;
	}
	if (!p || j > i) return false;
	e = p->data;
	return true;
}
//单链表的查找
LNode* LocateElem(LinkList L, ElemType e)
//此函数返回的是指针类型数据，即查找数据所在结构体LNode所在的地址
{
	LNode* p;
	p = L->next;
	while (p && p->data != e)
	{
		p = p->next;
	}
	return p;//NULL即为不存在，符合常规语法，方便调用
}
//单链表的插入
bool ListInsert(LinkList& L, int i, ElemType e)
{
	LNode* p;
	p = L;
	int j = 0;//可以直接插在头节点后，所以这样
	while (p && (j < i - 1))
		//i-1目的是让p直接指向要插入的第i个节点，如果为i，就会错过
	{
		p = p->next;++j;
	}
	if (!p || j > i - 1) return false;
	LNode* s = new LNode;
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;
}
//单链表的删除
bool ListDelete(LinkList& L, int i)
{
	LNode* p;
	p = L;
	int j = 0;
	//由于删除和插入一样需提前确认该元素地址，即为上一元素的next域
	while ((p->next) && (j < i - 1))
		//p->next由于删除需提前确认下一元素是否有，而不是空，而插入不同，因为可以插入在最后一个元素后
	{
		p = p->next;++j;
	}
	if (!(p->next) || (j > i - 1)) return false;
	LNode* q;
	q = p->next;
	p->next = q->next;
	delete q;
	return true;
}
//创建单链表
void CreateList_H(LinkList& L, int n)//前插法
{
	L = new LNode;
	L->next = NULL;
	for (int i = 0;i < n;i++)
	{
		LNode* p = new LNode;
		cin >> p->data;
		p->next = L->next;
		L->next = p;
	}
}
void CreateList_R(LinkList& L, int n)//后插法
{
	L = new LNode;
	L->next = NULL;
	LNode* r = L;
	for (int i = 0;i < n;i++)
	{
		LNode* p = new LNode;
		cin >> p->data;
		p->next = NULL;
		r->next = p;
		r = p;
	}
}
#include <iostream>
using namespace std;

// 这里假设你的代码已经包含在同一个文件中，或者通过头文件包含

int main() {
	LinkList L; // 定义单链表
	InitList(L); // 初始化单链表

	// 测试前插法创建单链表
	cout << "请输入前插法创建单链表的元素个数和元素值：" << endl;
	int n;
	cin >> n;
	CreateList_H(L, n);

	// 测试取值
	cout << "测试取值：请输入要获取的第 i 个元素的位置：" << endl;
	int i;
	cin >> i;
	ElemType e;
	if (GetElem(L, i, e)) {
		cout << "第 " << i << " 个元素的值为：" << e << endl;
	}
	else {
		cout << "获取第 " << i << " 个元素失败！" << endl;
	}

	// 测试插入
	cout << "测试插入：请输入插入位置和插入值：" << endl;
	int pos, value;
	cin >> pos >> value;
	if (ListInsert(L, pos, value)) {
		cout << "插入成功！" << endl;
	}
	else {
		cout << "插入失败！" << endl;
	}

	// 测试删除
	cout << "测试删除：请输入要删除的第 i 个元素的位置：" << endl;
	cin >> i;
	if (ListDelete(L, i)) {
		cout << "删除成功！" << endl;
	}
	else {
		cout << "删除失败！" << endl;
	}

	// 测试查找
	cout << "测试查找：请输入要查找的元素值：" << endl;
	cin >> value;
	LNode* found = LocateElem(L, value);
	if (found) {
		cout << "找到元素 " << value << "，地址为：" << found << endl;
	}
	else {
		cout << "未找到元素 " << value << "！" << endl;
	}

	// 打印链表
	cout << "当前链表中的元素为：" << endl;
	LNode* p = L->next;
	while (p) {
		cout << p->data << " ";
		p = p->next;
	}
	cout << endl;

	return 0;
}